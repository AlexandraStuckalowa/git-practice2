# Лабораторная работа №5.

## Введение.
Cоздала новый репозиторий с именем "git-practice". Склонировала его. Создала файл  "example.txt", в который ввела структуру книги.

Далее добавила файл в индекс гита, создала коммит и отправила его в репозиторий:
![](images/1.png)

Создала новую ветку "feature-branch". Переключилась на нее. В файл "example.txt" добавила текст и создала коммит на этой ветке:
![](images/2.png)

Переключилась обратно в основную ветку и перенесла изменения из ветки feature-branch в основную:
![](images/3.png)

Проверила, что изменения успешно перенеслись в основную ветку:
![](images/4.png)

## Работа с ветками


Создала текстовый файл с базовой структурой книги:
![](images/111.png)

Создала ветку "feature-login" для разработки новой функциональности, внесла изменения в файл. Закоммитила их и отправила ветку на GitHub:

![](images/555.png)
![](images/5555.png)

## Работа с удаленным репозиторием

Вернулась на основную ветку и внесла изменения в описании книги.
![](images/777.png)

Закоммитила их и отправила на GitHub:
![](images/7777.png)

## Моделирование конфликта

 Перешла в ветку "feature-login" и изменила главу 2 в файле.
 ![](images/88.png)

 Закоммитила изменения и отправила их на GitHub:
![](images/8888.png)

## Разрешение конфликта

При возвращении в основную ветку и попытке слить изменения возникает конфликт:

![](images/9.png)
![](images/10.png)

Разрешаю его в файле (удаляю метки и оставляю нужные изменения):

![](images/11.png)

Создаю коммит и отправляю изменения на Github:

![](images/12.png)

## Автоматизация проверки формата файлов при коммите


  * Создайте bash-скрипт (например, check_format.sh), который будет выполнять проверку формата .txt файлов. Этот скрипт может использовать инструменты, такие как grep или другие, чтобы проверить соответствие формату.

  ```
  #!/bin/bash

# Нам нужны файлы, которые не содержат цифры (такой формат)
# Получаем список .txt файлов в текущей директории
files=$(ls *.txt 2>/dev/null)

# Цикл по всем .txt файлам
for file in $files; do
  # Используем grep для поиска нечётных цифр в файле
  grep -q '[13579]' "$file"

  # Проверяем статус выполнения предыдущей команды
  if [ $? -eq 0 ]; then
    echo "Файл $file не соответствует формату."
  else
    echo "Файл $file соответствует формату."
  fi
done
  ```
  
* Добавление скрипта в репозиторий.
    Поместите скрипт в папку, например, в .git/hooks и назовите его pre-commit. Убедитесь, что у него есть права на выполнение.

    ```
    cp check_format.sh .git/hooks/pre-commit
    chmod +x .git/hooks/pre-commit

    ```

  * Попробуйте внести изменения и закоммитить.

    Теперь, при каждой попытке закоммитить изменения, Git будет автоматически выполнять проверку формата файлов перед коммитом. 

![](./img/15.png)

## Использование Git Flow в проекте

Я установила Git Flow:
![](./img/16.png)

В корне репозитория выполнила инициализацию Git Flow:
![](./img/123.png)

Создала ветку для новой функциональности "task-management":
![](./img/124.png)

Внесла изменения в код для добавления функционала управления задачами в файл task_manager.py:
![](./img/19.png)

Выполнила коммит изменения по мере разработки:
![](./img/20.png)

После завершения разработки функции завершила фичу и объединила ее с основной веткой:
![](./img/211.png)

Переключилась на ветку "develop" и начала создание релиза:
![](./img/222.png)

Внесла изменения, связанные с релизом: обновила версию в файле version.txt:
![](./img/223.png)

Завершила релиз и объединила его с ветками "develop" и "main":
![](./img/24.png)

Отправила изменения на удаленный репозиторий:
![](./img/2555.png)